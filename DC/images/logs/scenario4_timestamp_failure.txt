============================================================
   SCENARIO 4: TIMESTAMP SERVER FAILURE
============================================================

This demonstrates automatic failover between timestamp servers
when one becomes unavailable, ensuring continued operation.

>>> INITIAL STATE:
    timestamp-service-1: Running (generates ODD timestamps)
    timestamp-service-2: Running (generates EVEN timestamps)
    
    Both services maintain monotonically increasing sequences.

>>> STEP 1: Verify both timestamp servers operational
    GET http://timestamp-service-1:8000/timestamp
    Response: { "timestamp": 1, "server_id": 1 }
    
    GET http://timestamp-service-2:8000/timestamp
    Response: { "timestamp": 2, "server_id": 2 }

>>> STEP 2: Stop timestamp-service-1
    Command: docker stop timestamp-service-1
    Result: timestamp-service-1 container stopped
    
    [docker logs]:
    timestamp-service-1 | INFO: Shutting down
    timestamp-service-1 | INFO: Application shutdown complete.
    timestamp-service-1 exited with code 0

>>> STEP 3: Write operations continue with automatic failover
    Coordinator attempts service-1 first, fails, falls back to service-2
    
    [coordinator logs]:
    Timestamp service http://timestamp-service-1:8000 failed: 
        [Errno -2] Name or service not known, trying fallback...
    Got timestamp 4 from http://timestamp-service-2:8000
    
    Write Operations (all using EVEN timestamps from server-2):
    +----------+------------+-----------------------------+
    | Write #  | Timestamp  | Source                      |
    +----------+------------+-----------------------------+
    | 1        | 4 (even)   | timestamp-service-2         |
    | 2        | 6 (even)   | timestamp-service-2         |
    | 3        | 8 (even)   | timestamp-service-2         |
    | 4        | 10 (even)  | timestamp-service-2         |
    +----------+------------+-----------------------------+
    
    All writes successful despite service-1 being down!

>>> STEP 4: Coordinator Failover Logic
    
    async def get_timestamp():
        services = TIMESTAMP_SERVICES.copy()
        random.shuffle(services)  # Load balancing
        
        for service_url in services:
            try:
                response = await client.get(f"{service_url}/timestamp")
                return response.json()["timestamp"]
            except Exception as e:
                print(f"Service failed, trying fallback...")
                continue
        
        raise HTTPException(503, "All timestamp services failed")

============================================================
   KEY OBSERVATIONS
============================================================

[OK] Timestamp service failure detected within 2 second timeout
[OK] Coordinator automatically failed over to backup service
[OK] All timestamps remain EVEN (4, 6, 8, 10) - failover worked
[OK] No writes were lost or delayed significantly
[OK] Global ordering preserved (timestamps monotonically increasing)
[OK] Failover transparent to client - no error responses

============================================================
   TIMESTAMP SERVICE DESIGN
============================================================

Why Two Timestamp Servers?
* Eliminates single point of failure
* Odd/Even split prevents conflicts between servers
* Each server maintains independent counter
* Load balancing distributes requests

Ordering Guarantee:
* Server-1: 1, 3, 5, 7, 9, 11, ...
* Server-2: 2, 4, 6, 8, 10, 12, ...
* Combined: Total ordering maintained even with failover
